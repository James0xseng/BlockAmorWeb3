
// vulnerability-scan.ts
'use server';

/**
 * @fileOverview Smart Contract Vulnerability Scanner.
 *
 * - vulnerabilityScan - A function that handles the smart contract vulnerability scanning process.
 * - VulnerabilityScanInput - The input type for the vulnerabilityScan function.
 * - VulnerabilityScanOutput - The return type for the vulnerabilityScan function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const VulnerabilityScanInputSchema = z.object({
  smartContractCode: z
    .string()
    .describe('The smart contract code to scan for vulnerabilities.'),
  userTier: z.enum(['free', 'pro', 'enterprise']).optional().default('free')
    .describe('The user tier, which may affect the level of detail in the scan results.'),
});
export type VulnerabilityScanInput = z.infer<typeof VulnerabilityScanInputSchema>;

const VulnerabilityScanOutputSchema = z.object({
  vulnerabilities: z
    .array(z.string())
    .describe('A list of vulnerabilities found in the smart contract code.'),
  suggestedFixes: z
    .array(z.string())
    .describe('A list of suggested fixes for the vulnerabilities.'),
  securityScore: z
    .number()
    .describe('A security score for the smart contract code, from 0 to 100.'),
  tierApplied: z.string().optional().describe('The tier level applied for this scan response.'),
});
export type VulnerabilityScanOutput = z.infer<typeof VulnerabilityScanOutputSchema>;

// Define a new schema that includes the dynamically generated tierInstructions for the prompt
const PromptInputSchema = VulnerabilityScanInputSchema.extend({
  tierInstructions: z.string().optional()
});

export async function vulnerabilityScan(input: VulnerabilityScanInput): Promise<VulnerabilityScanOutput> {
  return vulnerabilityScanFlow(input);
}

const prompt = ai.definePrompt({
  name: 'vulnerabilityScanPrompt',
  input: {schema: PromptInputSchema}, // Use the extended schema here
  output: {schema: VulnerabilityScanOutputSchema},
  prompt: `You are a smart contract security expert. You will analyze the given smart contract code for common vulnerabilities such as reentrancy, integer overflow, gas limit issues, and others.

  {{{tierInstructions}}}

  Based on your analysis, you will provide a list of vulnerabilities found, suggested fixes for each vulnerability, and a security score for the smart contract code (0-100, higher is better).
  Also, include a 'tierApplied' field in your output, indicating which tier's instructions were followed (e.g., "free", "pro", "enterprise").

  Smart Contract Code:
  \`\`\`
  {{{smartContractCode}}}
  \`\`\`

  Respond in a structured format.
  `, // end of prompt
});

const vulnerabilityScanFlow = ai.defineFlow(
  {
    name: 'vulnerabilityScanFlow',
    inputSchema: VulnerabilityScanInputSchema, // External function uses this
    outputSchema: VulnerabilityScanOutputSchema,
  },
  async (input: VulnerabilityScanInput) => { // Ensure flow input type matches
    let tierInstructions = '';
    const tierToApply = input.userTier || 'free';

    if (tierToApply === 'pro') {
      tierInstructions = 'This scan is for a Pro tier user. Please provide detailed explanations for vulnerabilities and comprehensive remediation strategies. Mention that Pro level analysis was applied.';
    } else if (tierToApply === 'enterprise') {
      tierInstructions = 'This scan is for an Enterprise tier user. Provide an exhaustive, in-depth analysis. Discuss potential business impacts, advanced attack vectors, and offer detailed code examples for fixes where appropriate. Emphasize that Enterprise level analysis was applied.';
    } else {
      tierInstructions = 'This scan is for a Free tier user. Provide standard analysis. Mention that Free level analysis was applied.';
    }
    
    // Prepare input for the prompt, including the generated tierInstructions
    const promptPayload = {
      smartContractCode: input.smartContractCode,
      tierInstructions: tierInstructions,
      // We don't pass userTier directly to the prompt template,
      // but it's part of the input to this flow for logic.
      // The AI will set `tierApplied` in its output based on `tierInstructions`.
    };

    const {output} = await prompt(promptPayload);
    // Ensure the output includes the tierApplied, or set it based on input as a fallback.
    // The prompt now asks AI to set tierApplied.
    return output!;
  }
);
